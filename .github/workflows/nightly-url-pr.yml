name: Comment on pull request
on:
  workflow_run:
    workflows: ['Build and Push']
    types: [completed]
permissions:
  actions: read
  issues: write
  pull-requests: write
jobs:
  pr_comment:
    if: github.event.workflow_run.event == 'pull_request' && github.event.workflow_run.conclusion == 'success'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/github-script@v8
        with:
          script: |
            async function upsertComment(owner, repo, issue_number, purpose, body) {
              const {data: comments} = await github.rest.issues.listComments(
                {owner, repo, issue_number});

              const marker = `<!-- bot: ${purpose} -->`;
              body = marker + "\n" + body;

              const existing = comments.filter((c) => c.body.includes(marker));
              if (existing.length > 0) {
                const last = existing[existing.length - 1];
                core.info(`Updating comment ${last.id}`);
                await github.rest.issues.updateComment({
                  owner, repo,
                  body,
                  comment_id: last.id,
                });
              } else {
                core.info(`Creating a comment in issue / PR #${issue_number}`);
                await github.rest.issues.createComment({issue_number, body, owner, repo});
              }
            }

            const {owner, repo} = context.repo;
            const run_id = ${{github.event.workflow_run.id}};

            const pull_requests = ${{ toJSON(github.event.workflow_run.pull_requests) }};
            if (!pull_requests.length) {
              return core.error("This workflow doesn't match any pull requests!");
            }

            const artifacts = await github.paginate(
              github.rest.actions.listWorkflowRunArtifacts, {owner, repo, run_id});
            if (!artifacts.length) {
              return core.error(`No artifacts found`);
            }
            let body = `Download the artifacts for this pull request:\n`;
            const osLabels = {
              win: "Windows",
              linux: "Linux",
              mac: "macOS",
              freebsd: "FreeBSD",
            };
            const groups = new Map();
            for (const art of artifacts) {
              const name = art.name;
              const parts = name.split("_");
              // Extract OS prefix from parts[1] by removing trailing digits
              const osKey = parts.length >= 2 ? parts[1].replace(/\d+$/, "") : "other";
              const osLabel = osLabels[osKey] || "Other";
              // Extract architecture: for 3+ parts use parts[2:], for 2 parts extract digits from parts[1]
              let arch;
              if (parts.length >= 3) {
                arch = parts.slice(2).join("_");
              } else if (parts.length === 2) {
                // Extract digits/suffix from parts[1] (e.g., "win64" -> "64", "win32" -> "32")
                const match = parts[1].match(/\d+$/);
                arch = match ? match[0] : parts[1];
              } else {
                arch = name.replace(/^go2rtc_/, "");
              }
              if (!groups.has(osLabel)) groups.set(osLabel, []);
              groups.get(osLabel).push({
                label: arch,
                url: `https://nightly.link/${owner}/${repo}/actions/artifacts/${art.id}.zip`,
              });
            }

            const order = ["Windows", "Linux", "macOS", "FreeBSD", "Other"];
            for (const osLabel of order) {
              const items = groups.get(osLabel);
              if (!items || !items.length) continue;
              items.sort((a, b) => a.label.localeCompare(b.label));
              body += `\n\n**${osLabel}**`;
              for (const item of items) {
                body += `\n- [${item.label}.zip](${item.url})`;
              }
            }

            core.info("Review thread message body:", body);

            for (const pr of pull_requests) {
              await upsertComment(owner, repo, pr.number,
                "nightly-link", body);
            }
